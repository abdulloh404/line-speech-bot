import * as speech from "@google-cloud/speech";
import axios from "axios";
import express from "express";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs";
import path from "path";
import stringSimilarity from "string-similarity";
import "dotenv/config";
import {
  Client,
  middleware,
  MiddlewareConfig,
  ClientConfig,
} from "@line/bot-sdk";

const port = process.env.PORT;
const baseUrl = process.env.BASE_URL;

const app = express();
app.use(express.json());
// app.use(middleware(config));

const config: ClientConfig & MiddlewareConfig = {
  channelAccessToken: process.env.LINE_ACCESS_TOKEN!,
  channelSecret: process.env.LINE_CHANNEL_SECRET!,
};

const client = new Client(config);
const speechClient = new speech.SpeechClient();

let paramNoArray = ["1", "1", "1", "1", "1", "1", "1", "1", "1"];

app.get("/fetch", (req, res) => {
  let returnValue = JSON.stringify(paramNoArray, null, 2);
  res.status(200).send(returnValue);
});

app.post("/webhook", async (req, res) => {
  console.log(
    "üì• Received Webhook Request:",
    JSON.stringify(req.body, null, 2)
  );

  const events = req.body.events;
  for (const event of events) {
    if (event.message.type === "audio") {
      try {
        console.log(`üé§ Received Audio Message: ${event.message.id}`);
        await handleAudioMessage(event);
      } catch (error) {
        console.error("Error handling audio message:", error);
      }
    }
  }
  res.sendStatus(200);
});

app.get("/command", (req, res) => {
  // get parameter from url
  let param = req.query.no;
  let returnValue = paramNoArray[Number(param) - 1];
  res.status(200).send(returnValue);
});

const keywordFilePath = path.join(__dirname, "json/detcted-keyword.json");
const keywordData: string[][] = JSON.parse(
  fs.readFileSync(keywordFilePath, "utf-8")
);

export function detectKeywords(transcript: string): number[] {
  const detectedIndices: number[] = [];
  const lowerText = transcript.toLowerCase();

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö motor run (index 0) ‡∏Å‡πà‡∏≠‡∏ô motor stop (index 1)
  if (keywordData[0].some((kw) => lowerText.includes(kw.toLowerCase()))) {
    detectedIndices.push(0);
    paramNoArray[0] = paramNoArray[0] === "1" ? "0" : "1"; // Toggle ‡∏Ñ‡πà‡∏≤
  } else if (
    keywordData[1].some((kw) => lowerText.includes(kw.toLowerCase()))
  ) {
    detectedIndices.push(1);
    paramNoArray[1] = paramNoArray[1] === "1" ? "0" : "1"; // Toggle ‡∏Ñ‡πà‡∏≤
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö motor percent (index 2) ‡πÅ‡∏•‡∏∞‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤ 1-100
  const percentRegex = /(\d{1,3})\s*(?:%|‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô)/i;
  const percentMatch = transcript.match(percentRegex);
  if (percentMatch && percentMatch[1]) {
    const percent = parseInt(percentMatch[1], 10); // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
    if (percent >= 1 && percent <= 100) {
      detectedIndices.push(2);
      paramNoArray[2] = percent.toString(); // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á 1-100
    }
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ï‡∏∂‡∏Å 1-4 (index 3-6)
  for (let i = 3; i <= 6; i++) {
    const buildingNumber = i - 2;
    if (
      (lowerText.includes(`‡∏ï‡∏∂‡∏Å ${buildingNumber}`) ||
        keywordData[i].some((kw) => lowerText.includes(kw.toLowerCase()))) &&
      (lowerText.includes("‡∏ä‡∏°") || lowerText.includes("‡∏î‡∏π"))
    ) {
      detectedIndices.push(i);
      paramNoArray[i] = paramNoArray[i] === "1" ? "0" : "1"; // Toggle ‡∏Ñ‡πà‡∏≤
      break;
    }
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö head office (index 7)
  if (
    (lowerText.includes("office") || lowerText.includes("‡∏≠‡∏≠‡∏ü‡∏ü‡∏¥‡∏®")) && // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏Ñ‡πà‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ "office" ‡∏´‡∏£‡∏∑‡∏≠ "‡∏≠‡∏≠‡∏ü‡∏ü‡∏¥‡∏®"
    lowerText.includes("‡∏ï‡∏∂‡∏Å") &&
    (lowerText.includes("‡∏ä‡∏°") || lowerText.includes("‡∏î‡∏π"))
  ) {
    detectedIndices.push(7);
    paramNoArray[7] = paramNoArray[7] === "1" ? "0" : "1"; // Toggle ‡∏Ñ‡πà‡∏≤
  }

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö multi purpose (index 8)
  if (
    (lowerText.includes("‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏≠‡πÄ‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå") ||
      lowerText.includes("‡∏ï‡∏∂‡∏Å‡∏≠‡πÄ‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå")) &&
    (lowerText.includes("‡∏ä‡∏°") || lowerText.includes("‡∏î‡∏π"))
  ) {
    detectedIndices.push(8);
    paramNoArray[8] = paramNoArray[8] === "1" ? "0" : "1"; // Toggle ‡∏Ñ‡πà‡∏≤
  }

  return detectedIndices;
}

export async function handleAudioMessage(event: any) {
  const messageId = event.message.id;
  const audioBuffer = await getAudioFromLINE(messageId);
  const audioPath = path.join("/tmp", `${messageId}.ogg`);
  const wavPath = path.join("/tmp", `${messageId}.wav`);
  fs.writeFileSync(audioPath, audioBuffer);

  await convertOggToWav(audioPath, wavPath);
  const transcript = await transcribeAudio(wavPath);
  console.log("Transcription:", transcript);

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏≤‡∏Å transcript
  const detectedIndices = detectKeywords(transcript);
  console.log("Detected Indices:", detectedIndices);

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ï‡∏≤‡∏° index ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö
  let responseText = `‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏™‡∏±‡πà‡∏á‡∏ß‡πà‡∏≤ "${transcript}"\n`;
  if (detectedIndices.length > 0) {
    responseText += `‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á:\n`;

    detectedIndices.forEach((idx) => {
      switch (idx) {
        case 0:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏±‡∏ö";
          break;
        case 1:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏¥‡∏î‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏±‡∏ö";
          break;
        case 2:
          // ‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
          const percentMatch = transcript.match(/\d{1,3}/);
          const percent = percentMatch ? percentMatch[0] : "xx";
          responseText += `- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß ‡∏°‡∏≠‡πÄ‡∏ï‡∏≠‡∏£‡πå ‡πÄ‡∏õ‡πá‡∏ô ${percent}%`;
          break;
        case 3:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å 1";
          break;
        case 4:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å 2";
          break;
        case 5:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å 3";
          break;
        case 6:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å 4";
          break;
        case 7:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å Head office";
          break;
        case 8:
          responseText += "- ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏û‡∏≤‡πÑ‡∏õ‡∏î‡∏π‡∏ï‡∏∂‡∏Å‡πÄ‡∏≠‡∏ô‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå";
          break;
      }
    });
  } else {
    responseText += "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö";
  }

  // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ó‡∏µ‡πà LINE
  await client.replyMessage(event.replyToken, {
    type: "text",
    text: responseText,
  });

  fs.unlinkSync(audioPath);
  fs.unlinkSync(wavPath);
}

async function getAudioFromLINE(messageId: string): Promise<Buffer> {
  const url = `https://api-data.line.me/v2/bot/message/${messageId}/content`;
  const response = await axios.get(url, {
    headers: { Authorization: `Bearer ${process.env.LINE_ACCESS_TOKEN}` },
    responseType: "arraybuffer",
  });
  return Buffer.from(response.data);
}

async function convertOggToWav(
  inputPath: string,
  outputPath: string
): Promise<void> {
  return new Promise((resolve, reject) => {
    ffmpeg(inputPath)
      .toFormat("wav")
      .on("end", () => resolve())
      .on("error", (err) => reject(err))
      .save(outputPath);
  });
}

async function transcribeAudio(filePath: string): Promise<string> {
  const audio = {
    content: fs.readFileSync(filePath).toString("base64"),
  };
  const request = {
    audio: audio,
    config: {
      encoding: "LINEAR16" as any,
      sampleRateHertz: 16000,
      languageCode: "th-TH",
    },
  };
  const [response] = await speechClient.recognize(request);
  return (
    response.results
      ?.map((result) => result.alternatives[0].transcript)
      .join("\n") || ""
  );
}

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
});
